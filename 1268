// TC O(NlogN + MlogN), SC O(logN)

class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        int n = products.size();
        vector<vector<string>> results;
        sort(products.begin(), products.end());
        
        string curr_str = "";
        for(int i = 0; i < searchWord.size(); i++) {
            curr_str += searchWord[i];
            
            int low = 0, high = n - 1;
            
            while(low <= high) {
                int mid = low + (high - low) / 2;
                
                if(products[mid] >= curr_str)
                    high = mid - 1;
                else
                    low = mid + 1;
            }
            
            vector<string> result;
            for(int j = low; j < low + 3 && j < n; j++) {
                if(products[j].find(curr_str) == 0)
                    result.push_back(products[j]);
            }
            
            results.push_back(result);
        }
        
        return results;
    }
};


// Trie O(N*K + m)

class TrieNode {
public:
    vector<string> suggestions;
    unordered_map<char, TrieNode*> children;
    TrieNode(): suggestions({}), children(unordered_map<char, TrieNode*>()) {}
};

class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& words, string search_word) {
        TrieNode *root = new TrieNode();
        
        for(auto &word: words) {
            TrieNode *node = root;
            
            for(char &w: word) {
                if(node -> children.find(w) == node -> children.end()) {
                    node -> children[w] = new TrieNode();
                }
                
                node = node -> children[w];
                node -> suggestions.push_back(word);
                sort(node -> suggestions.begin(), node -> suggestions.end());
                
                if(node -> suggestions.size() > 3) node -> suggestions.pop_back();
            }
        }
        
        int i = 0;
        vector<vector<string>> answer;
        TrieNode *node = root;
        for(char &w: search_word) {
            if(node -> children.find(w) != node -> children.end()) {
                node = node -> children[w];
                answer.push_back(node -> suggestions);
                i++;
            }
            else {
                break;
            }
        }
        
        for(i; i < search_word.size(); i++)
            answer.push_back({});
        
        return answer;
    }
};
