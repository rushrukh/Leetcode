// Naive max-heap soln: TC O(Nk log (Nk), SC O(Nk)

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<pair<int, ListNode*>> Q;
        ListNode* head = NULL;
        
        for(auto x: lists) {
            while(x) {
                Q.push({x -> val, x});
                x = x -> next;
            }
        }
        
        while(!Q.empty()) {
            ListNode* tmp = Q.top().second;
            Q.pop();
            tmp -> next = head;
            head = tmp;
        }
        
        return head;
    }
};


// Optimal Min-heap Soln: TC O(N log k), SC O(k)
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *dummy_head = new ListNode(-1);
        ListNode *prev = dummy_head;
        
        auto comp = [](ListNode *A, ListNode *B) {
          return A -> val > B -> val;  
        };
        
        priority_queue<ListNode*, vector<ListNode*>, decltype(comp)> Q(comp); 
        
        for(auto &list: lists)
            if(list)
                Q.push(list);
        
        while(!Q.empty()) {
            ListNode *curr = Q.top();
            Q.pop();
            
            prev -> next = curr;
            prev = prev -> next;
            
            if(curr && curr -> next)
                Q.push(curr -> next);
        }
        
        return dummy_head -> next;
        
    }
};
