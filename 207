// TC O(V + E), SC O(V + E)

class Solution {
public:
    unordered_set<int> course_done;
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        unordered_map<int, vector<int>> graph;
        
        for(auto &pre: prerequisites) {
            graph[pre[0]].push_back(pre[1]);
        }
        
        unordered_set<int> visited;
        for(auto &pair: graph) {
            bool result = DFS(graph, pair.first, visited);
            if(!result) return false;
            
        }
        
        return true;
    }
    
    bool DFS(unordered_map<int, vector<int>> &graph, int course, unordered_set<int> & visited) {
        if(!graph[course].size()) return true;
        if(visited.find(course) != visited.end()) return false;
        visited.insert(course);
        
        bool result = true;
        for(int &course_2: graph[course]) {
            result = DFS(graph, course_2, visited);
            if(!result) return false;
        }
        
        graph[course].clear(); // this is important
        return true;
    }
};



// 1. Create Adjacency List: there will be n items in the list. Each one of those will have the prerequisite courses listed.

// 2. We will visit all the courses.
// 3. For each course, we will visit all its prerequisites.
// 4. Before that, we will check if the course that we are now visiting, has it already been visited?
//    If yes, that means we are in a cycle, return false;
