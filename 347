// Min-Heap + HashMap Soln: TC O(N logk) SC O(N + k)

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        vector<int> result;
        
        for(int &num: nums)
            hash[num]++;
        
        auto comp = [&hash](int &i, int &j) {
            return hash[i] > hash[j];  
        };
        
        priority_queue<int, vector<int>, decltype(comp)> Q(comp);
        
        for(auto &x: hash) {
            Q.push(x.first);
            
            if(Q.size() > k)
                Q.pop();
        }
        
        while(!Q.empty()) {
            result.push_back(Q.top());
            Q.pop();
        }
        
        return result;
    }
};


// QuickSelect TC O(N), SC O(N)

class Solution {
public:
    int n = 0;
    vector<int> unique;
    unordered_map<int, int> hash;
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> result(k, 0);
        
        for(int &num: nums)
            hash[num]++;
        
        for(auto &p: hash)
            unique.push_back(p.first);
        
        n = unique.size();
        quickselect(0, n - 1, n - k);
        
        copy(unique.begin() + n - k, unique.end(), result.begin());
        
        return result;
    }
    
    void quickselect(int left, int right, int k) {
        // base case: if array size is 1, nothing to do
        if(left == right)
            return;
        
        int p = left + rand() % (right - left + 1);
        int pivot = partition(left, right, p); // think about parameters
        
        if(pivot == k)
            return;
        else if(pivot < k)
            quickselect(pivot + 1, right, k);
        else
            quickselect(left, pivot - 1, k);
    }
    
    int partition(int left, int right, int p) {
        int pivot_freq = hash[unique[p]], store_index = left;
        swap(unique[p], unique[right]);
        
        for(int i = left; i < right; i++) {
            if(hash[unique[i]] <= pivot_freq)
                swap(unique[i], unique[store_index++]);
        }
        swap(unique[right], unique[store_index]);
        
        return store_index;
    }
};
