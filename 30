/*

Time Complexity:

n = s.length()
a = words.length()
b = words[0].length()
p = a * b

Helper Function Time Complexity Analysis:
  - We run a loop for a times.
  - In each of those iterations, we create a substring of length b. 
  - In total, we do operations in O(a * b).
  - Rest of the operatiosn are O(1).
  
Hence, helper function is O(a * b).

Main Function Time Complexity Analysis:
  - We loop through the string s a total of n - (a * b) times.
  - In each of those iterations, we call the helper function.
  - In total, we do operations in O((n - ab) * ab)
  - We can say the upper bound is O(n * a * b)
  
  
Space Complexity: O(a) for the hash.
*/

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        int n = s.length(), words_length = words.size(), word_length = words[0].size();
        int pattern_length = words_length * word_length;
        vector<int> result;
        unordered_map<string, int> hash;
        
        for(auto &word: words)
            hash[word]++;
        
        for(int i = 0; i < n - pattern_length + 1; i++) {
            if(is_valid(s, i, hash, words_length, word_length))
                result.push_back(i);
        }
        
        return result;
    }
    bool is_valid(string &s, int starting_index, unordered_map<string, int> hash, int &words_length, int &word_length) {
        for(int i = 0; i < words_length; i++) {
            string curr_str = s.substr(starting_index, word_length);
            if(hash.find(curr_str) != hash.end() && hash[curr_str] > 0) {
                hash[curr_str]--;
                starting_index += word_length;
            }
            else {
                return false;
            }
        }
        
        return true;
    }
};


/*

Time Complexity:

n = s.length()
a = words.length()
b = words[0].length()
p = a * b

Helper Function Time Complexity Analysis:
  - We run a loop for n/b times: O(n/b).
  - In each of those iterations, we create a substring of length b: O(b). 
  - In total, we do operations in O(n/b * b): O(n)
  - Rest of the operatiosn are O(1).
  
Hence, helper function is O(n).

Main Function Time Complexity Analysis:
  - We call the helper function b times: O(b * n) => O(nb)
  - We create a hash of all the words: O(a)
  - We can say the upper bound is O(a + nb)
  
  
Space Complexity: O(a) for the hash.
*/


class Solution {
public:
    vector<int> result;
    unordered_map<string, int> hash;
    int word_length = 0, words_length = 0, pattern_length = 0;
    vector<int> findSubstring(string s, vector<string>& words) {
        word_length = words[0].size(); 
        words_length = words.size();
        pattern_length = word_length * words_length;
        
        for(string &word: words)
            hash[word]++;
        
        for(int i = 0; i < word_length; i++) {
            valid_substr(s, i);
        }
        
        return result;
    }
    void valid_substr(string &s, int starting_index) {
        int left = starting_index, right = starting_index;
        unordered_map<string, int> tmp_hash;
        
        while(right < s.length() - word_length + 1) {
            string curr_str = s.substr(right, word_length);
            
            if(hash.find(curr_str) != hash.end()) {
                tmp_hash[curr_str]++;
            }
            right += word_length;
            
            if(right - left == pattern_length) {
                if(hash == tmp_hash) {
                    result.push_back(left);
                }
                
                string old_str = s.substr(left, word_length);
                if(tmp_hash.find(old_str) != tmp_hash.end() && tmp_hash[old_str] > 0)
                    tmp_hash[old_str]--;
                
                left += word_length;
            }
        }        
    }
};
