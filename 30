/*

Time Complexity:

n = s.length()
a = words.length()
b = words[0].length()
p = a * b

Helper Function Time Complexity Analysis:
  - We run a loop for a times.
  - In each of those iterations, we create a substring of length b. 
  - In total, we do operations in O(a * b).
  - Rest of the operatiosn are O(1).
  
Hence, helper function is O(a * b).

Main Function Time Complexity Analysis:
  - We loop through the string s a total of n - (a * b) times.
  - In each of those iterations, we call the helper function.
  - In total, we do operations in O((n - ab) * ab)
  - We can say the upper bound is O(n * a * b)
  
  
Space Complexity: O(a) for the hash.
*/

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        int n = s.length(), words_length = words.size(), word_length = words[0].size();
        int pattern_length = words_length * word_length;
        vector<int> result;
        unordered_map<string, int> hash;
        
        for(auto &word: words)
            hash[word]++;
        
        for(int i = 0; i < n - pattern_length + 1; i++) {
            if(is_valid(s, i, hash, words_length, word_length))
                result.push_back(i);
        }
        
        return result;
    }
    bool is_valid(string &s, int starting_index, unordered_map<string, int> hash, int &words_length, int &word_length) {
        for(int i = 0; i < words_length; i++) {
            string curr_str = s.substr(starting_index, word_length);
            if(hash.find(curr_str) != hash.end() && hash[curr_str] > 0) {
                hash[curr_str]--;
                starting_index += word_length;
            }
            else {
                return false;
            }
        }
        
        return true;
    }
};
